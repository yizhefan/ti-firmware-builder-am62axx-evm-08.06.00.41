<!-- HTML header for doxygen 1.8.11-->
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.15"/>
<title>Vision Apps Design: Infrastructure : Console IO</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(initResizable);
/* @license-end */</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="stylesheet.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectlogo"><img alt="Logo" src="ti_logo.png"/></td>
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Vision Apps Design
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.15 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md_internal_docs_doxy_cfg_design_content_pages_04000_infrastructure_console_io.html','');});
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">Infrastructure : Console IO </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><h1><a class="anchor" id="did_infrastructure_console_io_requirements"></a>
Requirements Addressed</h1>
<ul>
<li><a href="https://jira.itg.ti.com/browse/ADASVISION-1800">https://jira.itg.ti.com/browse/ADASVISION-1800</a></li>
</ul>
<h1><a class="anchor" id="did_infrastructure_console_io_intro"></a>
Introduction</h1>
<h2><a class="anchor" id="did_infrastructure_console_io_purpose"></a>
Purpose</h2>
<p>This design topic describes the integration of user input and output via a command line like interface.</p>
<h2><a class="anchor" id="did_infrastructure_console_io_short_desc"></a>
Short Application Description</h2>
<p>The below features are integrated as part of console IO</p><ul>
<li>Logging via a printf API<ul>
<li>Here stdio printf API is redirected to a log writer API such that all prints for different CPUs get logged to a shared memory</li>
<li>A log reader thread then reads these string and outputs to the console device</li>
<li>Console device will be UART</li>
<li>This logging infrastructure will not affect the system characteristic or real time performance as this is implemented as delayed print mechanism</li>
</ul>
</li>
<li>Command line interface<ul>
<li>Here a command line interface is provided to input read from UART</li>
<li>Based on keywords entered by the user, specific pre-registered functions wil be invoked</li>
<li>In, RTOS systems, this will act as a command line interface to trigger applications/demos</li>
<li>In, Linux systems, standard linux command line interface will be used and this module will be disabled.</li>
</ul>
</li>
</ul>
<p>NOTE: The CLI module is not a general purpose shell and is not meant to replace one. This module allows users to invoke handlers associated with a keyword (command). Typically handlers will run some OpenVX app or they will query the system and print some useful information, ex, SoC system load, memory consumption etc.</p>
<h2><a class="anchor" id="did_infrastructure_console_io_io_format"></a>
Input and Output format</h2>
<p>na</p>
<h1><a class="anchor" id="did_infrastructure_console_io_dir_structure"></a>
Directory Structure</h1>
<pre class="fragment">utils/console_io/
├── include
│   ├── app_cli.h           # CLI user callbable APIs
│   ├── app_log.h           # Log reader/writer user callbable APIs
│   └── app_uart.h          # UART IO user callbable APIs
└── src
    ├── app_cli.c           # command line interface implementation
    ├── app_log_reader.c    # logger implementation to read from shared memory and output to device
    ├── app_log_writer.c    # logger implementation to write to shared memory
    └── app_uart.c          # UART IO implementation using UART LLD from PDK
</pre><h1><a class="anchor" id="did_infrastructure_console_io_diagrams"></a>
Diagrams</h1>
<h2><a class="anchor" id="did_infrastructure_console_io_sequence_diagram"></a>
Sequence Diagram</h2>
<p>na</p>
<h2><a class="anchor" id="did_infrastructure_console_io_component_interaction"></a>
Component Interaction</h2>
<h3>Log reader and writer</h3>
<div class="image">
<img src="app_cons_io_log_rdwr.png" alt="app_cons_io_log_rdwr.png"/>
<div class="caption">
Log reader and writer</div></div>
<h3>Command line interface</h3>
<div class="image">
<img src="app_cons_io_cli_task.png" alt="app_cons_io_cli_task.png"/>
<div class="caption">
CLI Task</div></div>
<h1><a class="anchor" id="did_infrastructure_console_io_resource_usage"></a>
Resource usage</h1>
<h2>Log reader and writer</h2>
<ul>
<li>This module will take as input a pointer to shared memory where log writers will log their prints and log reader will from this area<ul>
<li>There can be only one log reader in a system</li>
<li>There will one log writer per CPU in a system</li>
</ul>
</li>
<li>Log reader will run as low priority thread, priority configurable by user. Default will be lowest priority</li>
<li>Log reader will run periodically at user configured polling interval Default will be 1ms</li>
<li>In RTOS systems, stdio printf will redirect to the Log writer API</li>
</ul>
<h2>Command line interface</h2>
<ul>
<li>No task will be created for CLI by the "console_io" module.</li>
<li>User will run "appCliHandleCmd(&amp;is_exit)" in a loop until "is_exit" returns as true<ul>
<li>This allows users/demos to nest calling of "app_cli_execute" to show sub-menu/commands while a demo is running</li>
</ul>
</li>
</ul>
<h2>UART</h2>
<ul>
<li>UART module will take UART instance ID as parameter from user and create the UART LLD</li>
</ul>
<h1><a class="anchor" id="did_infrastructure_console_io_error_handling"></a>
Error handling</h1>
<h2>Log reader and writer</h2>
<ul>
<li>In log writer, if space is not available in shared memory to write the sring, then the caller will not block, it will drop the string and return</li>
<li>In log reader, if no string is available for reading from shared memory and writing to console, log reader will sleep for user configured time and try again</li>
</ul>
<h2>Command line interface</h2>
<ul>
<li>CLI will call handlers for registered commands, if a unknown command is encoutered, CLI will output "Unsupport command [&lt;command name&gt;]" to console and show the CLI prompt again</li>
</ul>
<h1><a class="anchor" id="did_infrastructure_console_io_interface"></a>
Interface</h1>
<h2><a class="anchor" id="did_infrastructure_console_io_interface_uart"></a>
UART</h2>
<h3><a class="anchor" id="did_infrastructure_console_io_interface_uart_ds"></a>
Data structures</h3>
<div class="fragment"><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"></div><div class="line">    uint32_t uart_instance_id; <span class="comment">/* 0..n, UART instance ID to use */</span></div><div class="line"></div><div class="line">} app_uart_init_prm_t</div></div><!-- fragment --><h3><a class="anchor" id="did_infrastructure_console_io_interface_uart_funcs"></a>
Functions</h3>
<div class="fragment"><div class="line"><span class="comment">/* init and create UART driver */</span></div><div class="line">int32_t appUartInit(app_uart_init_prm_t *prm);</div><div class="line"></div><div class="line"><span class="comment">/* deinit UART driver */</span></div><div class="line">int32_t appUartDeInit();</div><div class="line"></div><div class="line"><span class="comment">/* write string to UART device, string may or may not be terminated by new line char */</span></div><div class="line">int32_t appUartWriteString(<span class="keywordtype">char</span> *str, uint32_t max_size);</div><div class="line"></div><div class="line"><span class="comment">/* read string from UART device, string will be terminated by newline char, new line char will not be returned */</span></div><div class="line">int32_t appUartReadString(<span class="keywordtype">char</span> *str, uint32_t max_size, uint32_t *string_size);</div></div><!-- fragment --><h2><a class="anchor" id="did_infrastructure_console_io_interface_log_rd_wr"></a>
Log reader and writer</h2>
<h3><a class="anchor" id="did_infrastructure_console_io_interface_log_rd_wr_ds"></a>
Data structures</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define APP_LOG_MAX_CPUS        (16u)</span></div><div class="line"><span class="preprocessor">#define APP_LOG_MAX_CPU_NAME    ( 8u)</span></div><div class="line"><span class="preprocessor">#define APP_LOG_MEM_SIZE        (4*1024u)  </span><span class="comment">/* log memory for one CPU */</span><span class="preprocessor"></span></div><div class="line"><span class="preprocessor">#define APP_LOG_AREA_VALID_FLAG (0x1357231u)</span></div><div class="line"></div><div class="line"><span class="comment">/* callback to write string to console device */</span></div><div class="line"><span class="keyword">typedef</span> int (*app_log_device_send_string_f)(<span class="keywordtype">char</span> *string, uint32_t max_size);</div><div class="line"></div><div class="line"><span class="comment">/* shared memory structure for a specific CPU */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"></div><div class="line">    <span class="comment">/* init by reader to 0 */</span></div><div class="line">    uint32_t log_rd_idx;</div><div class="line"></div><div class="line">    <span class="comment">/* init by writer to 0 */</span></div><div class="line">    uint32_t log_wr_idx;</div><div class="line"></div><div class="line">    <span class="comment">/* init by writer to APP_LOG_AREA_VALID_FLAG.</span></div><div class="line"><span class="comment">       reader will ignore this CPU shared mem log</span></div><div class="line"><span class="comment">       until the writer sets this</span></div><div class="line"><span class="comment">       to APP_LOG_AREA_VALID_FLAG */</span></div><div class="line">    uint32_t log_area_is_valid;</div><div class="line"></div><div class="line">    <span class="comment">/* init by writer to CPU name, used by reader to add a prefix when writing to console device */</span></div><div class="line">    uint8_t  log_cpu_name[APP_LOG_MAX_CPU_NAME];</div><div class="line"></div><div class="line">    <span class="comment">/* memory into which logs are written by this CPU */</span></div><div class="line">    uint8_t  log_mem[APP_LOG_MEM_SIZE];</div><div class="line"></div><div class="line">} app_log_cpu_shared_mem_t;</div><div class="line"></div><div class="line"><span class="comment">/* shared memory structure for all CPUs, used by reader and writer CPUs */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"></div><div class="line">    app_log_cpu_shared_mem_t cpu_shared_mem[APP_LOG_MAX_CPUS]</div><div class="line"></div><div class="line">} app_log_shared_mem_t;</div><div class="line"></div><div class="line"><span class="comment">/* init parameters to use for appLogInit */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"></div><div class="line">    app_log_shared_mem_t *shared_mem;       <span class="comment">/* shared memory to use for logging, all CPUs must point to the same shared memory */</span></div><div class="line">    uint32_t self_cpu_index;                <span class="comment">/* index into shared memory area for self CPU to use to use when writing. Two CPUs must not use the same CPU index */</span></div><div class="line">    uint8_t  self_cpu_name[APP_LOG_MAX_CPU_NAME]; <span class="comment">/* self CPU name */</span></div><div class="line">    uin32_t  log_rd_enable;                 <span class="comment">/* 1: enable log reader, NOTE: there can be only 1 log reader, else only log writer is enabled */</span></div><div class="line">    uint32_t log_rd_task_pri;               <span class="comment">/* task priority for log reader */</span></div><div class="line">    uint32_t log_rd_poll_interval_in_msecs; <span class="comment">/* polling interval for log reader in msecs */</span></div><div class="line">    uint32_t log_rd_max_cpus;               <span class="comment">/* maximum CPUs that log into the shared memory */</span></div><div class="line">    app_log_device_send_string_f device_write; <span class="comment">/* write a string to a device specific function, by default this will be set to appUartWriteString() */</span></div><div class="line"></div><div class="line">} app_log_init_prm_t;</div></div><!-- fragment --><h3><a class="anchor" id="did_infrastructure_console_io_interface_log_rd_wr_funcs"></a>
Functions</h3>
<div class="fragment"><div class="line"><span class="comment">/* Initialize app_log_init_prm_t with default parameters</span></div><div class="line"><span class="comment"> * always call this function before calling appLogInit</span></div><div class="line"><span class="comment"> */</span></div><div class="line"><span class="keywordtype">void</span> appLogInitPrmSetDefault(app_log_init_prm_t *prms);</div><div class="line"></div><div class="line"><span class="comment">/* Init Log reader and log writer,</span></div><div class="line"><span class="comment">   This function also does init to redirect printf to appLogPrintf for RTOS systems</span></div><div class="line"><span class="comment">*/</span></div><div class="line">int32_t appLogInit(app_log_init_prm_t *prms);</div><div class="line"></div><div class="line"><span class="comment">/* De-init log reader and log writer */</span></div><div class="line">int32_t appLogDeInit();</div><div class="line"></div><div class="line"><span class="comment">/* Write a string to shared memory</span></div><div class="line"><span class="comment"> * user can use this API or the stdio printf API</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appLogPrintf(<span class="keywordtype">char</span> *<span class="keywordtype">string</span>, ...);</div></div><!-- fragment --><h2><a class="anchor" id="did_infrastructure_console_io_interface_cli"></a>
Command line interface</h2>
<h3><a class="anchor" id="did_infrastructure_console_io_interface_cli_ds"></a>
Data structures</h3>
<div class="fragment"><div class="line"><span class="preprocessor">#define APP_CLI_MAX_PROMPT_NAME     (16u)</span></div><div class="line"></div><div class="line"><span class="comment">/* command handler callback */</span></div><div class="line">typdef int32_t (*app_cli_cmd_handler_f)(<span class="keywordtype">int</span> argc, <span class="keywordtype">char</span> *argv[]);</div><div class="line"></div><div class="line"><span class="comment">/* callback to write string to console device */</span></div><div class="line"><span class="keyword">typedef</span> int (*app_cli_device_send_string_f)(<span class="keywordtype">char</span> *string, uint32_t max_size);</div><div class="line"></div><div class="line"><span class="comment">/* callback to read string from console device */</span></div><div class="line"><span class="keyword">typedef</span> int (*app_cli_device_get_string_f)(<span class="keywordtype">char</span> *string, uint32_t max_size, uint32_t *string_size);</div><div class="line"></div><div class="line"><span class="comment">/* CLI init parameters */</span></div><div class="line"><span class="keyword">typedef</span> <span class="keyword">struct </span>{</div><div class="line"></div><div class="line">    app_cli_device_send_string_f device_write; <span class="comment">/* device specific callback to write string to device, by default appUartWriteString() is used */</span></div><div class="line">    app_cli_device_get_string_f device_read;  <span class="comment">/* device specific callback to read string from device, by default appUartReadString() is used */</span></div><div class="line">    <span class="keywordtype">char</span> cli_prompt_name[APP_CLI_MAX_PROMPT_NAME]   <span class="comment">/* CLI prompt name, by default &quot;ti&quot; will be used */</span></div><div class="line">} app_cli_init_prm_t;</div></div><!-- fragment --><h3><a class="anchor" id="did_infrastructure_console_io_interface_cli_funcs"></a>
Functions</h3>
<div class="fragment"><div class="line"><span class="comment">/* set default parameters for CLI */</span></div><div class="line"><span class="keywordtype">void</span> appCliInitPrmSetDefault(app_cli_init_prm_t *);</div><div class="line"></div><div class="line"><span class="comment">/* init CLI */</span></div><div class="line">int32_t appCliInit(app_cli_init_prm_t *);</div><div class="line"></div><div class="line"><span class="comment">/* de-init CLI */</span></div><div class="line">int32_t appCliDeInit();</div><div class="line"></div><div class="line"><span class="comment">/* Register a handler for system command &#39;cmd&#39;</span></div><div class="line"><span class="comment"> * A system command is a command that can be invoked at point during application invokation</span></div><div class="line"><span class="comment"> * ex, while a application use-case is running</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appCliRegisterSystemCmd(<span class="keywordtype">char</span> *cmd, app_cli_cmd_handler_f *cmd_handler);</div><div class="line"></div><div class="line"><span class="comment">/* Register a handler for application command &#39;cmd&#39;</span></div><div class="line"><span class="comment"> * Once a application command is invoke, additional application commands</span></div><div class="line"><span class="comment"> * cannot be invoked until this application finishes execution.</span></div><div class="line"><span class="comment"> * System commands and &quot;Application sub-commands&quot; can be invoked while</span></div><div class="line"><span class="comment"> * a application is running.</span></div><div class="line"><span class="comment"> * An application handler should register application specific sub-commands</span></div><div class="line"><span class="comment"> * which can be invoked while a application runs</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appCliRegisterAppCmd(<span class="keywordtype">char</span> *cmd, app_cli_cmd_handler_f *cmd_handler);</div><div class="line"></div><div class="line"><span class="comment">/* Register a handler for application sub-commands &#39;cmd&#39;</span></div><div class="line"><span class="comment"> * This are commands specific to the currently running application</span></div><div class="line"><span class="comment"> * ex, handler to stop current application would be different for different</span></div><div class="line"><span class="comment"> * applications.</span></div><div class="line"><span class="comment"> *</span></div><div class="line"><span class="comment"> * This commands can be invoked only after a application command is executed</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appCliRegisterAppSubCmd(<span class="keywordtype">char</span> *cmd, app_cli_cmd_handler_f *cmd_handler);</div><div class="line"></div><div class="line"><span class="comment">/* Unregisters all application sub-cmds, when a application command is executed</span></div><div class="line"><span class="comment"> * CLI unregisteres all previous registered app sub-cmds</span></div><div class="line"><span class="comment"> * applications should register any sub-cmds they wish to handle while the application</span></div><div class="line"><span class="comment"> * runs exeplicitly</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appCliUnRegisterAllAppSubCmds();</div><div class="line"></div><div class="line"><span class="comment">/* waits to read input from user and invokes handler based on</span></div><div class="line"><span class="comment">   the command that is entered.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   After handling one command, the function returns.</span></div><div class="line"><span class="comment">   If unsupport command is entered, function returns.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   User should call this function in a loop to get the effect of a CLI.</span></div><div class="line"><span class="comment"></span></div><div class="line"><span class="comment">   If user enters &#39;exit&#39;, is_exit flag is set to 1</span></div><div class="line"><span class="comment">   User can use this flag to break out of the loop.</span></div><div class="line"><span class="comment"> */</span></div><div class="line">int32_t appCliHandleCmd(uint32_t *is_exit);</div></div><!-- fragment --><h2><a class="anchor" id="did_infrastructure_console_io_interface_ex"></a>
Example API calls and CLI interaction</h2>
<h3><a class="anchor" id="did_infrastructure_console_io_interface_init_ex"></a>
Example init sequence</h3>
<h4><a class="anchor" id="did_infrastructure_console_io_interface_init_host_ex"></a>
Host CPU init and main</h4>
<div class="fragment"><div class="line"><span class="preprocessor">#pragma DATA_SECTION(gAppLogSharedMem, .bss:nonCacheSharedMem)</span></div><div class="line"><span class="preprocessor">#pragma DATA_ALIGN(gAppLogSharedMem, 1024)</span></div><div class="line">app_log_shared_mem_t gAppLogSharedMem;</div><div class="line"></div><div class="line">app_uart_init_prm_t gAppUartPrm;</div><div class="line">app_cli_init_prm_t gAppCliPrm;</div><div class="line">app_log_init_prm_t gAppLogPrm;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myHostInit() {</div><div class="line"></div><div class="line">    appUartInitPrmSetDefault(&amp;gAppUartPrm);</div><div class="line">    appCliInitPrmSetDefault(&amp;gAppCliPrm);</div><div class="line">    appLogInitPrmSetDefault(&amp;gAppLogPrm);</div><div class="line"></div><div class="line">    gAppUartPrm.uart_instance_id = 0;</div><div class="line">    gAppLogPrm.shared_mem = &amp;gAppLogSharedMem;</div><div class="line">    gAppLogPrm.self_cpu_index = Ipc_mp_self();</div><div class="line">    strcpy(gAppLogPrm.self_cpu_name, Ipc_mp_getName(Ipc_mp_self()));</div><div class="line">    gAppLogPrm.log_rd_enable = 1;</div><div class="line">    gAppLogPrm.log_rd_max_cpus = Ipc_mp_getNumProcessors();</div><div class="line"></div><div class="line">    appUartInit(&amp;gAppUartPrm);</div><div class="line">    appCliInit(&amp;gAppCliPrm);</div><div class="line">    appLogInit(&amp;gAppLogPrm);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myHostMain() {</div><div class="line"></div><div class="line">    uint32_t is_exit = 0;</div><div class="line"></div><div class="line">    myHostInit();</div><div class="line">    <span class="keywordflow">while</span>(!is_exit) {</div><div class="line">        appCliHandleCmd(&amp;is_exit);</div><div class="line">    }</div><div class="line">    myHostExit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myHostDeInit() {</div><div class="line">    appCliDeInit();</div><div class="line">    appLogDeInit();</div><div class="line">    appUartDeInit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="preprocessor">#### Remote CPU init and main {#did_infrastructure_console_io_interface_init_remote_ex}</span></div><div class="line"></div><div class="line">~~~C</div><div class="line"></div><div class="line"><span class="preprocessor">#pragma DATA_SECTION(gAppLogSharedMem, .bss:nonCacheSharedMem)</span></div><div class="line"><span class="preprocessor">#pragma DATA_ALIGN(gAppLogSharedMem, 1024)</span></div><div class="line">app_log_shared_mem_t gAppLogSharedMem;</div><div class="line"></div><div class="line">app_log_init_prm_t gAppLogPrm;</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myRemoteInit() {</div><div class="line"></div><div class="line">    appLogInitPrmSetDefault(&amp;gAppLogPrm);</div><div class="line"></div><div class="line">    gAppLogPrm.shared_mem = &amp;gAppLogSharedMem;</div><div class="line">    gAppLogPrm.self_cpu_index = Ipc_mp_self();</div><div class="line">    strcpy(gAppLogPrm.self_cpu_name, Ipc_mp_getName(Ipc_mp_self()));</div><div class="line"></div><div class="line">    appLogInit(&amp;gAppLogPrm);</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myRemoteMain() {</div><div class="line"></div><div class="line">    myRemoteInit();</div><div class="line">    <span class="keywordflow">while</span>(1);</div><div class="line">    myRemoteExit();</div><div class="line">}</div><div class="line"></div><div class="line"><span class="keywordtype">void</span> myRemoteDeInit() {</div><div class="line">    appLogDeInit();</div><div class="line">}</div></div><!-- fragment --><h3><a class="anchor" id="did_infrastructure_console_io_interface_cli_ex"></a>
Example CLI interaction</h3>
<pre class="fragment">System started, starting CLI !!!

cli:/&gt;
cli:/&gt; help

Supported system commands,
  help                - print this help
  info                - show device and binary information
  exit                - exit current application

Supported application commands,
  capture_display     - run capture+display app
  surround_view       - run surround view application

cli:/&gt; capture_display --cfg app_capture_display.cfg

Starting appilcation "capture_display"

cli:/capture_display&gt; help

Supported system commands,
  help                - print this help
  info                - show device and binary information
  exit                - exit current application

Supported application sub-commands,
  pause               - pause display
  profile             - show application profile information

cli:/capture_display&gt; exit

Exiting appilcation "capture_display"

cli:/&gt; xyz
Unsupported command, [xyz]

cli:/&gt; exit

System shutdown !!!
</pre><h1><a class="anchor" id="did_infrastructure_console_io_dar"></a>
Design Analysis and Resolution (DAR)</h1>
<h2><a class="anchor" id="did_infrastructure_console_io_dar_01"></a>
Design Decision : Init Sequence</h2>
<p>Decide how to init the UART, CLI and logger modules.</p>
<h3><a class="anchor" id="did_infrastructure_console_io_dar_01_criteria"></a>
Design Criteria: Init Sequence</h3>
<p>As part of init sequence, system integrator needs to make below decisions</p><ul>
<li>which UART instance to use for IO ?</li>
<li>where will the shared memory be located in the memory map ?</li>
<li>which API to use to read and write strings ?</li>
<li>how to run the CLI - in a spearate thread or in the main thread ?</li>
</ul>
<p>These questions are dependant on the customer use-case, memory map, board setup. Goal is to not creep in these specific details within console_io implementation.</p>
<h3><a class="anchor" id="did_infrastructure_console_io_dar_01_alt_01"></a>
Design Alternative: Init sequence inside the module</h3>
<ul>
<li>Here we have a appConsoleInit() and that does everything internally.</li>
</ul>
<p>Advantages</p><ul>
<li>Simpler for application when all of above parameters are fixed</li>
</ul>
<p>Disadvantages</p><ul>
<li>The implementation in console_io would become dependant on board (UART), CPU type (host or remote CPU), memory map (shared memory)</li>
</ul>
<h3><a class="anchor" id="did_infrastructure_console_io_dar_01_alt_02"></a>
Design Alternative: Init sequence inside the application</h3>
<ul>
<li>Here we have a init for each sub-module with all board, use-case, memory-map specific parameters taken as input.</li>
</ul>
<p>Advantages</p><ul>
<li>Implementation independant of board, use-case, memory-map.</li>
</ul>
<p>Disadvantages</p><ul>
<li>The app init sequence is more eloborate. A wrapper can be put at app level to make the init sequence simpler</li>
</ul>
<h3><a class="anchor" id="did_infrastructure_console_io_dar_01_decision"></a>
Final Decision</h3>
<p>Use "Init sequence inside the application" to keep console_io independant of board and use-case. </p>
</div></div><!-- PageDoc -->
</div><!-- contents -->
</div><!-- doc-content -->
<!-- HTML footer for doxygen 1.8.11-->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.15 </li>
  </ul>
</div>
</body>
</html>
